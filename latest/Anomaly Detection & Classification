def build_efficientnet_model(input_shape=(512, 512, 1), num_classes=4):
    """
    Builds a dual-branch EfficientNet model for classification.
    
    This model uses two branches, one for raw images and one for Fourier-transformed images,
    fused with an MLP.
    """
    # --- Raw Image Branch ---
    raw_input = Input(shape=input_shape, name='raw_input')
    # EfficientNet requires 3-channel input, so we replicate the channel
    raw_input_3ch = layers.Concatenate(axis=-1)([raw_input, raw_input, raw_input])
    
    # Load EfficientNet pre-trained on ImageNet or medical imaging (if available)
    base_model_raw = EfficientNetB0(
        include_top=False,
        weights='imagenet',
        input_tensor=raw_input_3ch,
        input_shape=(512, 512, 3)
    )
    base_model_raw.trainable = False  # Freeze for transfer learning initially
    x_raw = base_model_raw.output
    x_raw = layers.GlobalAveragePooling2D()(x_raw)
    
    # --- Fourier Image Branch ---
    fourier_input = Input(shape=input_shape, name='fourier_input')
    # EfficientNet requires 3-channel input
    fourier_input_3ch = layers.Concatenate(axis=-1)([fourier_input, fourier_input, fourier_input])
    
    base_model_fourier = EfficientNetB0(
        include_top=False,
        weights='imagenet',
        input_tensor=fourier_input_3ch,
        input_shape=(512, 512, 3)
    )
    base_model_fourier.trainable = False # Freeze for transfer learning initially
    x_fourier = base_model_fourier.output
    x_fourier = layers.GlobalAveragePooling2D()(x_fourier)
    
    # --- Fusion & Classification Head ---
    fused_features = layers.concatenate([x_raw, x_fourier])
    
    # MLP classifier for fusion
    x = Dense(256, activation='relu')(fused_features)
    x = Dropout(0.5)(x)
    x = Dense(num_classes, activation='softmax', name='classification_output')(x)
    
    model = Model(inputs=[raw_input, fourier_input], outputs=x)
    
    # Compile the model
    model.compile(
        optimizer=Adam(learning_rate=1e-4),
        loss='categorical_crossentropy', # Multi-class classification loss
        metrics=['accuracy', tf.keras.metrics.AUC(name='auc_roc')]
    )
    
    return model

# Example usage:
# efficientnet_model = build_efficientnet_model()
# efficientnet_model.summary()
